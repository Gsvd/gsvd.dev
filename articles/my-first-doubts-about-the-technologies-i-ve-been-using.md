---
title: "My first doubts about the technologies I've been using"
date: "October 25, 2023"
order: 1
---

## Disclaimer

Be warned: in this post, I'll be making a sweeping generalization about all JavaScript technologies, mixing frontend and backend. It might be hard to see, but don’t get stuck on that – try to understand the core idea behind it: technological reevaluation is the central point.

## The JavaScript Golden Age

During my studies, even though I kept this a secret: I loved PHP. I used it a lot, allowing me to quickly bring my ideas or projects to life. I used it with frameworks, without frameworks; I just couldn't get enough of it.

However, as the section title suggests, we were in the midst of the "JavaScript Golden Age". If you weren't one of those hippies who loved web apps with 25MB of JavaScript, fourteen external libraries to work, state issues everywhere, and logic on the interface: you weren't a real developer. And yet, secretly, I kept cherishing the idea that it was simpler and safer to manage everything server-side and just display it. That’s how I got absorbed into the JavaScript and fullstack development universe, because it looked good, because the community seemed expert, because they spoke loudly.

By the way, the term "fullstack" isn’t the issue here. It’s just that its deep meaning has been completely lost over the years, and NO, to me, a fullstack developer isn’t someone who’s equally good at frontend and backend. It's more complex than that, and I'll get back to it someday.

## The First Doubts

Soon enough in my professional life, I encountered problems that, in my opinion, shouldn't even have arisen and were directly related to these technological choices:

- Multi state, multi state, multi state, multi state: CLASSIC! (so much so that I won’t even delve into this point). But we know how to avoid it, right?
- SEO, so classic too. But then why not use a framework of frameworks to solve the problems of the previous framework?
- Optimization. Not even for complex code (quite the opposite). But reached very quickly when you have large amounts of data to process.
- Cost. Holy crap, if you want to proudly wear the JS fullstack developer cap, you better not host your projects yourself: what an idea. The cloud is so great. Well, I like setting up my web server myself.
- ORMs. Nothing to do with everything else, I just wanted to vent. Go learn SQL.

## It's Nice, but I'll Pass

It was only recently that I started learning Go. My first test was to simply rewrite a script we used for data processing in Node.js (I'll spare you the details). Nothing complex, I purely rewrote it in half a day when I had never touched a line of Go before. The result? From several tens of minutes to a few tens of seconds. Dirty. So much so that my commit had an NSFW tag.

But watch out, Gophers, this post isn't about praising Go. It's just to point out JavaScript's weaknesses (Node.js / Bun / whatever you get my drift). I'm convinced I would've gotten a similarly satisfying result with other languages.

And that's when I realized I didn't want it anymore.